<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0">
	<link rel="stylesheet" href="style.css">
	<!--<link rel="stylesheet" href="dark.css">-->
	<script src="client.js"></script>
	<script>

class State {
	constructor(value) {
		this.value = value
	}
	valueOf() {
		return this.value
	}
}

class StateWriter extends State {
	constructor(value, stateStack) {
		super(value)
		this.stateStack = stateStack
	}
	set(value) {
		this.value = value
		this.stateStack.onUpdate(this)
	}
	release() {
		this.stateStack.releaseWriter(this)
	}
}

class StateStack {
	constructor(defaultVal) {
		this.states = [new State(defaultVal)]
	}
	addWriter(initialValue) {
		// gee I sure hope this isn't a race condition
		this.states.unshift( new StateWriter(initialValue, this) )
		this._update()
		return this.current()
	}
	releaseWriter(writer) {
		//apparently this is how you remove an element
		this.states = this.states.splice(this.states.indexOf(writer), 1)
	}
	valueOf() {
		return this.current().valueOf()
	}
	_update() {
		showState()
	}
	onUpdate(writer) {
		if ( writer === this.current() ) { this._update() }
	}
	current() {
		return this.states[0]
	}
}

var state = [[0, 0], false, false, false].map(val => new StateStack(val))
var activeWriters = []

var debug;
function showState() {
	debug.innerHTML = state.map( v => v.valueOf() );
}
function setState(evt, i, val) {
	console.log(evt)
	state[i] = val;
	showState();
	send(state)
}
function addRequiredListeners(element, stateIndex, defaultState, activeState) {
	['mousedown', "touchstart"].forEach( evt =>
		element.addEventListener(evt, setState [stateIndev, activeState])
	);
	['mouseup', "touchend"].forEach( evt =>
		element.addEventListener(evt, setState [stateIndev, defaultState])
	);
}

class PressEvent extends Event {
//add an identifier
}

function getEventIndex(evt) {
	switch (typeof(evt)) {
		case 'TouchEvent':
			return evt.changedTouches[0].identifier + 1;
		default:
			return 0;
	}
}

function handlePressEvent(evt) {
	i = getEventIndex(evt)
	//pressEvt = (evt as PressEvent)
	pressEvt = evt
	pressEvt.id = i
	pressEvt.type = "mousedown"
	pressEvt.path[0].dispatchEvent(pressEvt)
}

function handleReleaseEvent(evt) {
	writer = activeWriters[getEventIndex(evt)]
	writer.release()
}
	</script>
</head>
<body>
	<pre id="debug" class="display"> </pre>
	<div id=input>
		<div id="left">
			<table class="cluster of-4 dpad">
				<tr>
					<td><button id="dpad-u" onmousedown="setState(event, 0, [0,1])">▲</button></td>
					<td><button id="dpad-r" onmousedown="setState(event, 0, [1,0])">►</button></td>
				</tr><tr>
					<td><button id="dpad-l" onmousedown="setState(event, 0, [-1,0])">◄</button></td>
					<td><button id="dpad-d" onmousedown="setState(event, 0, [0,-1])">▼</button></td>
				</tr>
			</table>
		</div>
		<div id="right">
			<table class="cluster of-2">
				<tr>
					<td><button id="west" onmousedown="setState(event, 1, true)"></button></td>
					<td><button id="south" onmousedown="setState(event, 2, true)"></button></td>
				</tr>
			</table>
			<button class="small" onclick="printEvent(event)">start</button>
		</div>
	</div>
	<script>
      debug = document.getElementById("debug");
document.addEventListener("touchstart", handlePressEvent)
document.addEventListener("mousedown", handlePressEvent)
document.addEventListener("mouseup", handleReleaseEvent)
document.addEventListener("touchend", handleReleaseEvent)
		showState()
	</script>
</body>
